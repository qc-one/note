<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .container {
            /* position: relative; */
            width: 150px;
            height: 200px;
            /* display: flex; */
            display: grid;
            grid-template-rows: 50px 50px 50px;
            grid-template-columns: 50px 50px 50px；
        }
        
        .child {
            /* position: absolute; */
            width: 50px;
            height: 50px;
            background-color: #f0f0f0;
            /* border: 1px solid #ccc; */
            /* text-align: center;
            line-height: 50px; */
            
        }
        
        .child:nth-child(1) {
            /* top: 0;
            left: 0; */
            /* justify-content: flex-start; */
            grid-column-start: 1;
            grid-column-end: 2;
            grid-row-start: 1;
            grid-row-end: 2;
        }
        
        .child:nth-child(2) {
            /* top: 50px;
            left: 50px; */
            /* justify-content: center; */
            grid-column-start: 2;
            grid-column-end: 3;
            grid-row-start: 2;
            grid-row-end: 3;
        }
        
        .child:nth-child(3) {
            /* top: 100px;
            left: 100px; */
            /* justify-content: flex-end; */
            grid-column-start: 3;
            grid-column-end: 4;
            grid-row-start: 3;
            grid-row-end: 4;
        }
    </style>
</head>
<body>
    <p>
        噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。
    
        问君西游何时还？畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天，使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此，嗟尔远道之人胡为乎来哉！
    
        剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！</p>
      <p>
        噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。
    
        问君西游何时还？畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天，使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此，嗟尔远道之人胡为乎来哉！
    
        剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！</p>
      <p>
        噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。
    
        问君西游何时还？畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天，使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此，嗟尔远道之人胡为乎来哉！
    
        剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！</p>
      <img data-src="./images/1.jpg" alt="">
      <img data-src="./images/2.jpg" alt="">
      <p>
        噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。
    
        问君西游何时还？畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天，使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此，嗟尔远道之人胡为乎来哉！
    
        剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！</p>
      <p>
        噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。
    
        问君西游何时还？畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天，使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此，嗟尔远道之人胡为乎来哉！
    
        剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！</p>
      <p>
        噫吁嚱，危乎高哉！蜀道之难，难于上青天！蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。
    
        问君西游何时还？畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天，使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此，嗟尔远道之人胡为乎来哉！
    
        剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！</p>
      <img data-src="./images/3.jpg" alt="">
    
    <!-- <button id="debounce">防抖</button>
    <button id="throttle">节流</button>
    <div class="container">
        <div class="child">1</div>
        <div class="child">2</div>
        <div class="child">3</div>
    </div> -->
    <script>
        const imgs = document.querySelectorAll('img'); //获取全部图片元素
        const winInner = window.innerHeight; //可视界面的高度

        function scrollFun() {
            imgs.forEach((img) => {
            const imgScrollTop = img.offsetTop; //图片距离文档顶部的距离
            const bodyScrollTop = document.body.scrollTop || document.documentElement.scrollTop; //浏览器滚动的长度
            if (imgScrollTop < winInner + bodyScrollTop) { //当图片距离文档顶部的距离小于可视界面的高度+浏览器滚动的长度时加载对应的图片
                img.setAttribute('src', img.getAttribute('data-src'));
            }
            })
        }
        
        window.onscroll = scrollFun;
        // let str = `
        //     fasffd d22dd 
        //     dffda ffd
        //     ddd
        // `
        // function strToarr(str) {
        //     let arr=str.split(/\n/);
        //     let result = []
        //     arr.forEach((item) => {
        //         if (item !== '' && item.trim() !== '') {
        //             result.push(item.trim().split(" "))
                    
        //         }
        //     })
        //     return result
        // }
        
        // console.log(strToarr(str));



        // const promiseAll=(promises)=>{
        //     let results = [];
        //     let length = promises.length;
        //     let promiseCount = 0;
        //     return new Promise((resolve, reject) => {
        //         for (let i = 0; i < promises.length; i++) {
        //             promises[i].then(res => {
        //                 results[i] = res;
        //                 promiseCount++;

        //                 if (promiseCount === length) {
        //                     resolve(results);
        //                 }
        //             }, err => {
        //                 reject(err);
        //             })
        //         }
        //     })
        // }
        // let p1=Promise.resolve(1);
        // let p2=Promise.resolve('hello I am No2');
        // let p3=Promise.resolve(3);
        // promiseAll([p1,p2,p3]).then((value)=>{
        //     console.log(value)
        // })// [1, "hello I am No2", 3]
        // let p1 = new Promise((resolve, reject) => {
        //     setTimeout(() => {
        //         resolve('success' + 11111);
        //     }, 3000)
        //     // reject('error' + 11111);
        // })
        // let p2 = new Promise((resolve, reject) => {
        //     resolve('success' + 22222);
        //     // reject('error' + 22222);
        // })
        // let p3 = new Promise((resolve, reject) => {
        //     resolve('success' + 33333);
        //     // reject('error' + 33333);
        // })
        // promiseAll([p1, p2, p3]).then((res) => {
        //     console.log(res);
        // }).catch((err) => {
        //     console.log(err);
        // })

        // let p1 = new Promise((resolve, reject) => {
        //     // setTimeout(() => {
        //     //     resolve('success' + 11111);
        //     // }, 3000)
        //     reject('error' + 11111);
        // })
        // let p2 = new Promise((resolve, reject) => {
        //     // resolve('success' + 22222);
        //     reject('error' + 22222);
        // })
        // let p3 = new Promise((resolve, reject) => {
        //     // resolve('success' + 33333);
        //     reject('error' + 33333);
        // })
        // Promise.any([p1, p2, p3]).then((res) => {
        //     console.log(res);
        // }).catch((err) => {
        //     console.log(err);
        // })
        // Promise.allSettled([p1, p2, p3]).then((res) => {
        //     console.log(res);
        // }).catch((err) => {
        //     console.log(err);
        // })
        // let a = () => {
        //     return new Promise((resolve, reject) => {
        //         let aa = false;
        //         if (aa) {
        //             resolve(aa+'111');
        //         } else {
        //             reject(aa+'222')
        //         }
        //     })
        // }
        // let b = () => {
        //     return new Promise((resolve, reject) => {
        //         let bb = true;
        //         if (bb) {
        //             resolve(bb+'333');
        //         } else {
        //             reject(bb+'444')
        //         }
        //     })
        // }
        // a().then(() => {
        //     return b()
        // }).then((res) => {
        //     console.log(res);
        // }).catch((err) => {
        //     console.log(err);
        // })

        let p1 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('success' + 11111);
            }, 3000)
            // reject('error' + 11111);
        })
        let p2 = new Promise((resolve, reject) => {
            // resolve('success' + 22222);
            reject('error' + 22222);
        })
        let p3 = new Promise((resolve, reject) => {
            resolve('success' + 33333);
            // reject('error' + 33333);
        })
        // Promise.all([p1, p2, p3]).then((res) => {
        //     console.log(res);
        // }).catch((err) => {
        //     console.log(err);
        // })
        // Promise.allSettled([p1, p2, p3]).then((res) => {
        //     console.log(res);
        // }).catch((err) => {
        //     console.log(err);
        // })
        function promiseAllSettled(promises) {
            let results = [];
            let length = promises.length;
            let promiseCount = 0;
            return new Promise((resolve, reject) => {
                for (let i = 0; i < promises.length; i++) {
                    promises[i].then(res => {
                        results[i] = {
                            status: 'fullfilled',
                            value: res
                        }
                        promiseCount++;
                        if (promiseCount === length) {
                            resolve(results);
                        }
                    }, err => {
                        results[i] = {
                            status: 'rejected',
                            value: err
                        }
                        promiseCount++;
                        if (promiseCount === length) {
                            reject(results);
                        }
                    })
                }
            })
        }
        promiseAllSettled([p1, p2, p3]).then((res) => {
            console.log(res);
        }).catch((err) => {
            console.log(err);
        })

        // function judgeNumber(num){
        //     var promise1 = new Promise(function(resolve,reject){
        //         num =5;
        //         if(num<5){
        //             resolve("num小于5，值为："+num);
        //         }else{
        //             reject("num不小于5，值为："+num);
        //         }
        //     });
        //     return promise1;
        // }
        // judgeNumber(6).then(
        //     function(message){
        //         console.log(message, 'resolve');
        //     },
        //     function(message){
        //         console.log(message, 'reject111');
        //         console.log(a);
        //     }
        // )
        // .catch(function(message){
        //     console.log(message, 'reject222');
        // })

        // eval('var a=1');
        // let b = eval('({a: 1234})')
        // console.log(a, eval('({a: 123})'), b);

        // let arr = [1, 2, 34];
        // for (let value in arr) {
        //     console.log(value); // 输出 '1', '2', '3' (按照数组顺序)
        // }

        // 深拷贝
        // function deepClone(source) {
        //     // null数据需要特殊处理
        //     if (source === null) {
        //         return source
        //     }
        //     // 校验要拷贝的数据是对象还是数组
        //     const target = Array.isArray(source) ? [] : {}
        //     for (const k in source) {
        //         const val = source[k]
        //         const valueType = typeof val
        //         // 校验拷贝的数据类型
        //         if (valueType === 'function') {
        //         target[k] = new Function(`return ${val.toString()}`)()
        //         } else if (valueType === 'object') {
        //         target[k] = deepClone(val)
        //         } else {
        //         target[k] = val
        //         }
        //     }
        //     return target
        // }
        // const obj1 = { name: 'dog', info: { age: 3 }, fn: function () {} }
        // const obj2 = deepClone(obj1)
        // obj2.name = 'cat'
        // obj2.info.age = 4
        // console.log(obj1) // { name: 'dog', info: { age: 3 }, fn: function(){} }
        // console.log(obj2) // { name: 'cat', info: { age: 4 }, fn: function(){} }

        // 手动实现bind
        // Function.prototype.bind2 = function (context) {
        //     var self = this;
        //     // 获取bind2函数从第二个参数到最后一个参数
        //     var args = Array.prototype.slice.call(arguments, 1);
        //     return function () {
        //         console.log(this, 11);
        //         // 这个时候的arguments是指bind返回的函数传入的参数
        //         var bindArgs = Array.prototype.slice.call(arguments);
        //         return self.apply(context, args.concat(bindArgs));
        //     }
        // }
        // var value = 2;
        // var foo = {
        //     value: 1
        // };
        // function bar(name, age) {
        //     console.log(this, 222);
        //     this.habit = 'shopping';
        //     console.log(this.value);
        //     console.log(name);
        //     console.log(age);
        // }
        // bar.prototype.friend = 'kevin';
        // var bindFoo = bar.bind(foo, 'daisy');
        // var obj = new bindFoo('18');
        // // undefined
        // // daisy
        // // 18
        // console.log(obj.habit);
        // console.log(obj.friend);
        // shopping
        // kevin

        // 手动实现call
        // Function.prototype.newCall = function(context){
        //     var ctx = arguments[0] || window;
        //     ctx.fn = this;
        //     var arr = []
        //     for(var i = 1; i < arguments.length;i++){
        //         arr.push('arguments[' + i + ']')
                
        //     }
        //     var result = eval('ctx.fn(' + arr.join(',')+')');
        //     delete ctx.fn
        //     return result
        // }
        // Function.prototype.newCall = function(context, ...args){
        //     context.fn = this;   //将当前调用myCall的函数赋值给这个属性
        //     const result = context.fn(...args); //处理参数，传入第一个参数后的其余参数,这里可以理解为obj.foo(...args)
        //     delete context.fn  //调用函数后即删除该Symbol属性
        //     return result
        // }
        // var foo = {
        //     value: 1
        // };
        // function bar(name) {
        //     console.log(this)
        //     console.log(name)
        //     console.log(this.value);
        // }
        // // bar.call(foo) // 1
        // bar.newCall(foo,"qin", 1)

        // 防抖
        // function debounce(fn, interval) {
        //     let timer = null; // 定时器
        //     return function() {
        //         // 清除上一次的定时器
        //         clearTimeout(timer);
        //         // 拿到当前的函数作用域
        //         let _this = this;
        //         // 拿到当前函数的参数数组
        //         let args = Array.prototype.slice.call(arguments, 0);
        //         // 开启倒计时定时器
        //         timer = setTimeout(function() {
        //             // 通过apply传递当前函数this，以及参数
        //             fn.apply(_this, args);
        //             // 默认300ms执行
        //         }, interval || 300)
        //     }
        // }
        // let debounceBtn = document.getElementById("debounce")
        // debounceBtn.onclick = debounce(function() {
        //     console.log('点击了');
        // }, 5000)
        
        // // 节流
        // function throttle(fn, interval) {
        //     let timer = null; // 定时器
        //     let firstTime = true; // 判断是否是第一次执行
        //     // 利用闭包
        //     return function() {
        //         // 拿到函数的参数数组
        //         let args = Array.prototype.slice.call(arguments, 0);
        //         // 拿到当前的函数作用域
        //         let _this = this;
        //         // 如果是第一次执行的话，需要立即执行该函数
        //         if(firstTime) {
        //             // 通过apply，绑定当前函数的作用域以及传递参数
        //             fn.apply(_this, args);
        //             // 修改标识为null，释放内存
        //             firstTime = null;
        //         }
        //         // 如果当前有正在等待执行的函数则直接返回
        //         if(timer) return;
        //         // 开启一个倒计时定时器
        //         timer = setTimeout(function() {
        //             // 通过apply，绑定当前函数的作用域以及传递参数
        //             // fn.apply(_this, args);
        //             // 清除之前的定时器
        //             timer = null;
        //             // 默认300ms执行一次
        //             firstTime = true;
        //         }, interval || 300)
        //     }
        // }
        // let throttleBtn = document.getElementById("throttle")
        // throttleBtn.onclick = throttle(function() {
        //     console.log('点击了');
        // }, 5000)

        // let set = new Set([0,12,3,3]);
        // console.log(set);
        // // for (let i = 0; i < set.length; i ++) {
        // //     console.log(set[i]);
        // // }
        // set.forEach((item) => {
        //     console.log(item);
        // })
        // let set = new Set(['red', 'green', 'blue']);
        // for (let item of set.keys()) {
        //     console.log(item);
        // }
        // let obj = {a:123}
        // let set = new Set([1, 4, 9]);
        // set.forEach((value, key) => {
        //     console.log(key + ' : ' + value)
        //     console.log(this); // window
        // }, obj)
        // set.forEach(function(value, key){
        //     console.log(key + ' : ' + value)
        //     console.log(this); // {a: 123}
        // }, obj)
        // for (let key of set) {
        //     console.log(key, 'key');
        // }
    </script>
</body>
</html>